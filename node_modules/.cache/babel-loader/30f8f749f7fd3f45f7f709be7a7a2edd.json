{"ast":null,"code":"import _ from 'lodash'; //                        style={style(resource[0] % 10, Math.floor(resource[0] / 10))}\n\nconst d = (arr, index) => Math.min(...arr.map(cell => Number(cell.index))) - 1;\n\nexport const pointToIndex = (arr, title) => {\n  //move to x=1, y=1\n  const dx = d(arr, \"x\");\n  const dy = d(arr, \"y\");\n  arr.forEach(point => {\n    point.x -= dx;\n    point.y -= dy;\n  }); //[{x: \"1\", y: \"2\", resource: \"WOOD\"},...] -> [[12,\"WOOD\"],...]\n\n  return arr.map(point => {\n    const index = point.x * 10 + point.y;\n    return title ? [index, point.resource.title] : [index, point.resource]; //and sort by index\n  }).sort((a, b) => {\n    return a[0] - b[0];\n  });\n};\nexport const preparedPattern = (pattern, board) => {\n  const preparedPattern = pattern.map(cell => {\n    return {\n      x: cell.toString().charAt(0),\n      y: cell.toString().charAt(1),\n      resource: board[cell]\n    };\n  });\n  const dx = d(preparedPattern, \"x\");\n  const dy = d(preparedPattern, \"y\");\n  return preparedPattern.map(cell => {\n    return {\n      x: cell.x - dx,\n      y: cell.y - dy,\n      resource: cell.resource\n    };\n  });\n};\nexport const rotateAndMirrorPattern = pattern1 => {\n  //[[12,\"WOOD\"],...] -> [{x: \"1\", y: \"2\", resource: \"WOOD\"},...]\n  const indexToPoint = arr => arr.map(square => {\n    return {\n      x: square[0] % 10,\n      y: Math.floor(square[0] / 10),\n      resource: square[1]\n    };\n  });\n\n  const test = [[12, \"WOOD\"]];\n  console.log(indexToPoint(test));\n  const rotated0pattern = indexToPoint(test);\n  console.log(rotated0pattern);\n\n  const rotate = arr => arr.map(point => {\n    return {\n      x: -point.y,\n      y: point.x,\n      resource: point.resource\n    };\n  });\n\n  const mirrorX = arr => arr.map(point => {\n    return {\n      x: -point.x,\n      y: point.y,\n      resource: point.resource\n    };\n  });\n\n  const mirrorY = arr => arr.map(point => {\n    return {\n      x: point.x,\n      y: -point.y,\n      resource: point.resource\n    };\n  });\n\n  const rotated1pattern = rotate(rotated0pattern);\n  const rotated2pattern = rotate(rotated1pattern);\n  const rotated3pattern = rotate(rotated2pattern);\n  const rez = [rotated0pattern, mirrorY(rotated0pattern), mirrorX(rotated0pattern), rotated1pattern, mirrorX(rotated1pattern), mirrorY(rotated1pattern), rotated2pattern, mirrorX(rotated2pattern), mirrorY(rotated2pattern), rotated3pattern, mirrorX(rotated3pattern), mirrorY(rotated3pattern)].map(pointPattern => pointToIndex(pointPattern));\n  return _.uniqWith(rez, _.isEqual);\n};","map":{"version":3,"sources":["D:\\Pro\\React\\tlt\\src\\components\\Buildings\\patternHandler.js"],"names":["_","d","arr","index","Math","min","map","cell","Number","pointToIndex","title","dx","dy","forEach","point","x","y","resource","sort","a","b","preparedPattern","pattern","board","toString","charAt","rotateAndMirrorPattern","pattern1","indexToPoint","square","floor","test","console","log","rotated0pattern","rotate","mirrorX","mirrorY","rotated1pattern","rotated2pattern","rotated3pattern","rez","pointPattern","uniqWith","isEqual"],"mappings":"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","sourcesContent":["import _ from 'lodash';\r\n//                        style={style(resource[0] % 10, Math.floor(resource[0] / 10))}\r\n\r\nconst d = (arr, index) => Math.min(...arr.map(cell => Number(cell.index))) - 1;\r\n\r\nexport const pointToIndex = (arr, title) => {\r\n    //move to x=1, y=1\r\n    const dx = d(arr, \"x\");\r\n    const dy = d(arr, \"y\");\r\n    arr.forEach(point => {\r\n        point.x -= dx;\r\n        point.y -= dy;\r\n    });\r\n    //[{x: \"1\", y: \"2\", resource: \"WOOD\"},...] -> [[12,\"WOOD\"],...]\r\n    return arr.map(point => {\r\n        const index = point.x * 10 + point.y;\r\n        return title ? [index, point.resource.title] : [index, point.resource]\r\n        //and sort by index\r\n    }).sort((a, b) => { return a[0] - b[0] });\r\n}\r\n\r\nexport const preparedPattern = (pattern, board) => {\r\n\r\n    const preparedPattern = pattern.map(cell => {\r\n        return {\r\n            x: cell.toString().charAt(0),\r\n            y: cell.toString().charAt(1),\r\n            resource: board[cell]\r\n        }\r\n    });\r\n\r\n    const dx = d(preparedPattern, \"x\");\r\n    const dy = d(preparedPattern, \"y\");\r\n\r\n    return preparedPattern.map(cell => {\r\n        return {\r\n            x: cell.x - dx,\r\n            y: cell.y - dy,\r\n            resource: cell.resource\r\n        }\r\n    });\r\n}\r\n\r\nexport const rotateAndMirrorPattern = pattern1 => {\r\n\r\n\r\n\r\n    //[[12,\"WOOD\"],...] -> [{x: \"1\", y: \"2\", resource: \"WOOD\"},...]\r\n    const indexToPoint = arr => arr.map(square =>  {\r\n        return {\r\n            x: square[0] % 10,\r\n            y: Math.floor(square[0] / 10),\r\n            resource: square[1]\r\n        }\r\n    });\r\n    \r\n    const test = [[12,  \"WOOD\",]]\r\n    console.log(indexToPoint(test));\r\n    const rotated0pattern = indexToPoint(test);\r\n    console.log(rotated0pattern);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    const rotate = arr => arr.map(point => { return { x: -point.y, y: point.x, resource: point.resource } });\r\n\r\n    const mirrorX = arr => arr.map(point => { return { x: -point.x, y: point.y, resource: point.resource } });\r\n\r\n    const mirrorY = arr => arr.map(point => { return { x: point.x, y: -point.y, resource: point.resource } });\r\n\r\n\r\n    const rotated1pattern = rotate(rotated0pattern);\r\n    const rotated2pattern = rotate(rotated1pattern);\r\n    const rotated3pattern = rotate(rotated2pattern);\r\n\r\n\r\n\r\n\r\n    const rez = [\r\n        rotated0pattern,\r\n        mirrorY(rotated0pattern),\r\n        mirrorX(rotated0pattern),\r\n\r\n        rotated1pattern,\r\n        mirrorX(rotated1pattern),\r\n        mirrorY(rotated1pattern),\r\n\r\n        rotated2pattern,\r\n        mirrorX(rotated2pattern),\r\n        mirrorY(rotated2pattern),\r\n\r\n        rotated3pattern,\r\n        mirrorX(rotated3pattern),\r\n        mirrorY(rotated3pattern)\r\n    ].map(pointPattern => pointToIndex(pointPattern));\r\n\r\n    return _.uniqWith(rez, _.isEqual);\r\n}"]},"metadata":{},"sourceType":"module"}