{"ast":null,"code":"const boardCalc = {\n  indexToX: index => index.toString().charAt(0).parseInt(),\n  indexToY: index => index.toString().charAt(1).parseInt(),\n  xyToIndex: (x, y) => parseInt(x.toString() + y.toString()),\n  getAdjacentIndexes: index => {\n    const x = boardCalc.indexToX(index);\n    const y = boardCalc.indexToY(index);\n    const adjacent = [];\n\n    if (x > 1) {\n      adjacent.push(boardCalc.xyToIndex(x - 1, y));\n    }\n\n    ;\n\n    if (x < 4) {\n      adjacent.push(boardCalc.xyToIndex(x + 1, y));\n    }\n\n    ;\n\n    if (y > 1) {\n      adjacent.push(boardCalc.xyToIndex(x, y - 1));\n    }\n\n    ;\n\n    if (y > 4) {\n      adjacent.push(boardCalc.xyToIndex(x, y + 1));\n    }\n\n    ;\n    console.log(\"index: \".concat(index, \"; adjacent: \").concat(adjacent));\n    return adjacent;\n  },\n  findBuildings: (board, buildingTitle) => board.indexes.filter(index => board[index].title === buildingTitle),\n  getAdjacentWithType: (board, index, type) => boardCalc.getAdjacentIndexes(index).filter(i => board[i].type === type)\n};\nexport const calcScore = {\n  //3VP for each Fed Cottage\n  Cottage: board => {\n    return 3 * board.fedCottages;\n  },\n  //1VP for each Fed Cottage for each Chapel\n  Chapel: board => {\n    return boardCalc.findBuildings(board, \"Chapel\").length * board.fedCottages;\n  },\n  //0\n  Farm: () => {\n    return 0;\n  },\n  //0-0,1-2, 2-5, 3-9, 4-14, 5+ - 20\n  Tavern: board => {\n    switch (boardCalc.findBuildings(board, \"Tavern\").length) {\n      case 0:\n        return 0;\n\n      case 1:\n        return 2;\n\n      case 2:\n        return 5;\n\n      case 3:\n        return 9;\n\n      case 4:\n        return 14;\n\n      default:\n        return 20;\n    }\n  },\n  // 1VP per each adjacent Cottage for each Well\n  Well: board => {\n    let score = 0;\n    boardCalc.findBuildings(board, \"Well\").forEach(wellIndex => {\n      score += boardCalc.getAdjacentWithType(board, wellIndex, 1).length;\n    });\n    return score;\n  },\n  Theatr: board => {\n    return \"Theatr\";\n  },\n  Factory: () => {\n    return 0;\n  }\n}; //simple case\n\nexport const calcFedCottages = (board, buildings) => {\n  const cottageNum = boardCalc.findBuildings(board, \"Cottage\").length;\n  const needFood = cottageNum * buildings[0].toBeFed;\n  const producedFood = boardCalc.findBuildings(board, buildings[2].title).length * buildings[2].canFeeds;\n\n  if (needFood > producedFood) {\n    return Math.floor(producedFood / buildings[0].toBeFed);\n  }\n\n  ;\n  return cottageNum;\n};","map":{"version":3,"sources":["D:\\Pro\\React\\tlt\\src\\components\\Buildings\\scoring.js"],"names":["boardCalc","indexToX","index","toString","charAt","parseInt","indexToY","xyToIndex","x","y","getAdjacentIndexes","adjacent","push","console","log","findBuildings","board","buildingTitle","indexes","filter","title","getAdjacentWithType","type","i","calcScore","Cottage","fedCottages","Chapel","length","Farm","Tavern","Well","score","forEach","wellIndex","Theatr","Factory","calcFedCottages","buildings","cottageNum","needFood","toBeFed","producedFood","canFeeds","Math","floor"],"mappings":"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","sourcesContent":["const boardCalc = {\r\n\r\n    indexToX: index => index.toString().charAt(0).parseInt(),\r\n    indexToY: index => index.toString().charAt(1).parseInt(),\r\n    xyToIndex: (x, y) => parseInt(x.toString() + y.toString()),\r\n\r\n    getAdjacentIndexes: index => {\r\n        const x = boardCalc.indexToX(index);\r\n        const y = boardCalc.indexToY(index);\r\n        const adjacent = [];\r\n        if (x > 1) { adjacent.push(boardCalc.xyToIndex(x - 1, y)) };\r\n        if (x < 4) { adjacent.push(boardCalc.xyToIndex(x + 1, y)) };\r\n        if (y > 1) { adjacent.push(boardCalc.xyToIndex(x, y - 1)) };\r\n        if (y > 4) { adjacent.push(boardCalc.xyToIndex(x, y + 1)) };\r\n        console.log(`index: ${index}; adjacent: ${adjacent}`);\r\n        return adjacent;\r\n    },\r\n\r\n    findBuildings: (board, buildingTitle) => board.indexes.filter(index => board[index].title === buildingTitle),\r\n\r\n    getAdjacentWithType: (board, index, type) => boardCalc.getAdjacentIndexes(index).filter(i => board[i].type === type),\r\n};\r\n\r\n\r\nexport const calcScore = {\r\n\r\n    //3VP for each Fed Cottage\r\n    Cottage: board => { return 3 * board.fedCottages },\r\n\r\n    //1VP for each Fed Cottage for each Chapel\r\n    Chapel: board => { return boardCalc.findBuildings(board, \"Chapel\").length * board.fedCottages },\r\n\r\n    //0\r\n    Farm: () => { return 0 },\r\n\r\n    //0-0,1-2, 2-5, 3-9, 4-14, 5+ - 20\r\n    Tavern: board => {\r\n        switch (boardCalc.findBuildings(board, \"Tavern\").length) {\r\n            case 0: return 0;\r\n            case 1: return 2;\r\n            case 2: return 5;\r\n            case 3: return 9;\r\n            case 4: return 14;\r\n            default: return 20;\r\n        }\r\n    },\r\n\r\n    // 1VP per each adjacent Cottage for each Well\r\n    Well: board => {\r\n        let score = 0;\r\n        boardCalc.findBuildings(board, \"Well\").forEach(wellIndex => {\r\n            score += boardCalc.getAdjacentWithType(board, wellIndex, 1).length\r\n        });\r\n        return score;\r\n    },\r\n\r\n    Theatr: board => { return \"Theatr\" },\r\n    Factory: () => { return 0 },\r\n};\r\n\r\n\r\n//simple case\r\nexport const calcFedCottages = (board, buildings) => {\r\n    const cottageNum = boardCalc.findBuildings(board, \"Cottage\").length;\r\n    const needFood = cottageNum * buildings[0].toBeFed;\r\n    const producedFood = boardCalc.findBuildings(board, buildings[2].title).length * buildings[2].canFeeds;\r\n    if (needFood > producedFood) { return Math.floor(producedFood / buildings[0].toBeFed) };\r\n    return cottageNum;\r\n}\r\n\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}