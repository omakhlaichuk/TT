{"ast":null,"code":"const boardCalc = {\n  indexToX: index => parseInt(index.toString().charAt(0)),\n  indexToY: index => parseInt(index.toString().charAt(1)),\n  xyToIndex: (x, y) => parseInt(x.toString() + y.toString()),\n  getAdjacent: index => {\n    const x = boardCalc.indexToX(index);\n    const y = boardCalc.indexToY(index);\n    const adjacent = [];\n\n    if (x > 1) {\n      adjacent.push(boardCalc.xyToIndex(x - 1, y));\n    }\n\n    ;\n\n    if (x < 4) {\n      adjacent.push(boardCalc.xyToIndex(x + 1, y));\n    }\n\n    ;\n\n    if (y > 1) {\n      adjacent.push(boardCalc.xyToIndex(x, y - 1));\n    }\n\n    ;\n\n    if (y < 4) {\n      adjacent.push(boardCalc.xyToIndex(x, y + 1));\n    }\n\n    ;\n    return adjacent;\n  },\n  getRow: index => {\n    const x = boardCalc.indexToX(index);\n    const row = [];\n\n    for (let i = 1; i < 5; i++) {\n      if (index !== parseInt(\"\".concat(x).concat(i))) {\n        row.push(parseInt(\"\".concat(x).concat(i)));\n      }\n    }\n\n    return row;\n  },\n  findBuildings: (board, buildingTitle) => board.indexes.filter(index => board[index].title === buildingTitle),\n  getAdjacentWithType: (board, index, type) => boardCalc.getAdjacent(index).filter(i => board[i].type === type)\n};\nexport const calcScore = {\n  //3VP for each Fed Cottage\n  Cottage: board => {\n    return 3 * board.fedCottages;\n  },\n  //1VP for each Fed Cottage for each Chapel\n  Chapel: board => {\n    return boardCalc.findBuildings(board, \"Chapel\").length * board.fedCottages;\n  },\n  //0\n  Farm: () => {\n    return 0;\n  },\n  //0-0,1-2, 2-5, 3-9, 4-14, 5+ - 20\n  Tavern: board => {\n    switch (boardCalc.findBuildings(board, \"Tavern\").length) {\n      case 0:\n        return 0;\n\n      case 1:\n        return 2;\n\n      case 2:\n        return 5;\n\n      case 3:\n        return 9;\n\n      case 4:\n        return 14;\n\n      default:\n        return 20;\n    }\n  },\n  // 1VP per each adjacent Cottage for each Well\n  Well: board => {\n    let score = 0;\n    boardCalc.findBuildings(board, \"Well\").forEach(wellIndex => {\n      score += boardCalc.getAdjacentWithType(board, wellIndex, 1).length;\n    });\n    return score;\n  },\n  //1VP for each unique building in the same row&column\n  Theatr: board => {\n    boardCalc.findBuildings(board, \"Theatr\").forEach(theatrIndex => {\n      console.log(boardCalc.getRow(theatrIndex));\n    });\n    return \"Theatr\";\n  },\n  //0\n  Factory: () => {\n    return 0;\n  }\n}; //simple case\n\nexport const calcFedCottages = (board, buildings) => {\n  const cottageNum = boardCalc.findBuildings(board, \"Cottage\").length;\n  const needFood = cottageNum * buildings[0].toBeFed;\n  const producedFood = boardCalc.findBuildings(board, buildings[2].title).length * buildings[2].canFeeds;\n\n  if (needFood > producedFood) {\n    return Math.floor(producedFood / buildings[0].toBeFed);\n  }\n\n  ;\n  return cottageNum;\n};","map":{"version":3,"sources":["D:\\Pro\\React\\tlt\\src\\components\\Buildings\\scoring.js"],"names":["boardCalc","indexToX","index","parseInt","toString","charAt","indexToY","xyToIndex","x","y","getAdjacent","adjacent","push","getRow","row","i","findBuildings","board","buildingTitle","indexes","filter","title","getAdjacentWithType","type","calcScore","Cottage","fedCottages","Chapel","length","Farm","Tavern","Well","score","forEach","wellIndex","Theatr","theatrIndex","console","log","Factory","calcFedCottages","buildings","cottageNum","needFood","toBeFed","producedFood","canFeeds","Math","floor"],"mappings":"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","sourcesContent":["const boardCalc = {\r\n\r\n    indexToX: index => parseInt(index.toString().charAt(0)),\r\n    indexToY: index => parseInt(index.toString().charAt(1)),\r\n    xyToIndex: (x, y) => parseInt(x.toString() + y.toString()),\r\n\r\n    getAdjacent: index => {\r\n        const x = boardCalc.indexToX(index);\r\n        const y = boardCalc.indexToY(index);\r\n        const adjacent = [];\r\n        if (x > 1) { adjacent.push(boardCalc.xyToIndex(x - 1, y)) };\r\n        if (x < 4) { adjacent.push(boardCalc.xyToIndex(x + 1, y)) };\r\n        if (y > 1) { adjacent.push(boardCalc.xyToIndex(x, y - 1)) };\r\n        if (y < 4) { adjacent.push(boardCalc.xyToIndex(x, y + 1)) };\r\n        return adjacent;\r\n    },\r\n\r\n    getRow: index => {\r\n        const x = boardCalc.indexToX(index);\r\n        const row = [];\r\n        for (let i = 1; i < 5; i++) {\r\n            if (index !== parseInt(`${x}${i}`)) {\r\n                row.push(parseInt(`${x}${i}`));\r\n            }\r\n        }\r\n        return row;\r\n    },\r\n\r\n    findBuildings: (board, buildingTitle) => board.indexes.filter(index => board[index].title === buildingTitle),\r\n\r\n    getAdjacentWithType: (board, index, type) => boardCalc.getAdjacent(index).filter(i => board[i].type === type),\r\n};\r\n\r\n\r\nexport const calcScore = {\r\n\r\n    //3VP for each Fed Cottage\r\n    Cottage: board => { return 3 * board.fedCottages },\r\n\r\n    //1VP for each Fed Cottage for each Chapel\r\n    Chapel: board => { return boardCalc.findBuildings(board, \"Chapel\").length * board.fedCottages },\r\n\r\n    //0\r\n    Farm: () => { return 0 },\r\n\r\n    //0-0,1-2, 2-5, 3-9, 4-14, 5+ - 20\r\n    Tavern: board => {\r\n        switch (boardCalc.findBuildings(board, \"Tavern\").length) {\r\n            case 0: return 0;\r\n            case 1: return 2;\r\n            case 2: return 5;\r\n            case 3: return 9;\r\n            case 4: return 14;\r\n            default: return 20;\r\n        }\r\n    },\r\n\r\n    // 1VP per each adjacent Cottage for each Well\r\n    Well: board => {\r\n        let score = 0;\r\n        boardCalc.findBuildings(board, \"Well\").forEach(wellIndex => {\r\n            score += boardCalc.getAdjacentWithType(board, wellIndex, 1).length\r\n        });\r\n        return score;\r\n    },\r\n\r\n    //1VP for each unique building in the same row&column\r\n    Theatr: board => {\r\n        boardCalc.findBuildings(board, \"Theatr\").forEach(\r\n            theatrIndex => { console.log(boardCalc.getRow(theatrIndex)) }\r\n        )\r\n        return \"Theatr\"\r\n    },\r\n\r\n    //0\r\n    Factory: () => { return 0 },\r\n};\r\n\r\n\r\n//simple case\r\nexport const calcFedCottages = (board, buildings) => {\r\n    const cottageNum = boardCalc.findBuildings(board, \"Cottage\").length;\r\n    const needFood = cottageNum * buildings[0].toBeFed;\r\n    const producedFood = boardCalc.findBuildings(board, buildings[2].title).length * buildings[2].canFeeds;\r\n    if (needFood > producedFood) { return Math.floor(producedFood / buildings[0].toBeFed) };\r\n    return cottageNum;\r\n}\r\n\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}